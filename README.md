# Условие:

Реализуйте программу “автодополнение”.  На вход подаются тексты произвольной длины. Затем, по запросу, программа дополняет слово по префиксу. Слово, которое подсказывает программа, должно быть самым популярным среди слов, добавленных ранее. Также можно использовать функцию “дописывание” и дописать несколько символов к уже введённому префиксу получив, возможно, другую подсказку.


Например:
Добавить текст: “яблоко яблоко яблоневый”
Запрос: “ябло”
Подсказка: “яблоко”
Дописывание: “н” (т.е. весь префикс -- “яблон”)
Подсказка: “яблоневый”
Добавить текст: “яблоня яблоня яблоня”
Запрос: “ябл”
Подсказка: “яблоня”
    
Интерфейс программы на ваше усмотрение. Достаточно консольного ввода-вывода. 
Желательно, чтобы при “дописывании” результат выводился быстрее, чем при запросе с чистой строки.

# Решение

Я решил писать прогамму на С++. Для решения будем хранить *unordered_map* и *set*. 

В *unordered_map* `dictionary_`будем хранить пары ключ-значение, где ключ это строка в словаре,а значение - количество таких строк в данном массиве.

Также сделаем 2 *set* `main_set` и `auxiliary_set`. В `main_set` будкм хранить упорядоченную последовательность наших строк, про `auxiliary_set` расскажу позже.
Основная идея в том, что поиск всех строк для конкретного префикса `prefix`,это все равно что рассмотреть множество всех строк в каком-то интервале, ограниченным `prefix` и `prefix + '{'`,так как символ '{' больше всех букв из 
**ascii**(Для удобства разрешим только строчные маленькие буквы в алфавите). Поэтому для того, чтобы рассмотреть это подмножество `main_set`,добавим при необходимости `prefix` и `prefix + '{'` в наш сет и проитерируемся по нашему выбранному куску и найдем самый популярный элемент. Тут крайний случай может возникать в том, что `prefix` уже лежит в `main_set`. В коде этот сучай аккуратно(нет) обработан. 

`auxiliary_set` нужен для добавлении букв в слово поиска. С помощью этого сета мы  будем ограничивать область поиска с `main_set` на `auxiliary_set`. Это существенно ускорит повторный поиск.

# Сложность

1. Добавление `k` элементов в словарь из `n` элементов *O(log(n + k) * k)*
2. Поиск наилучшей строки к префиксу в словаре из `n` где всего подходящий строк `k` элементов *O(log(n) * k)*, в худшем случае *O(log(n) * n)*, на деле куда быстрее.
3. повторный уточняющий поиск - как минимум *O(log(n) * k)*, на деле куа быстрее.

# Запуск

`g++ autocomplete.cpp`

`./a.out`

Более подробная инструкцию вы прочитаете при работе с консолью.



